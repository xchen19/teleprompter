<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>口播提词器</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
    background: #111;
    color: #fff;
    min-height: 100vh;
    overflow: hidden;
    -webkit-user-select: none;
    user-select: none;
  }

  #editor {
    display: flex;
    flex-direction: column;
    height: 100vh;
    height: 100dvh;
    padding: 16px;
    gap: 12px;
  }

  #editor h1 {
    font-size: 20px;
    font-weight: 600;
    text-align: center;
    flex-shrink: 0;
  }

  #textInput {
    flex: 1;
    background: #222;
    border: 1px solid #444;
    border-radius: 12px;
    color: #fff;
    font-size: 16px;
    line-height: 1.6;
    padding: 14px;
    resize: none;
    outline: none;
    -webkit-user-select: text;
    user-select: text;
  }

  #textInput::placeholder { color: #666; }

  .controls {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .control-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .control-row label {
    font-size: 14px;
    color: #aaa;
    width: 70px;
    flex-shrink: 0;
  }

  .control-row input[type="range"] {
    flex: 1;
    accent-color: #0a84ff;
  }

  .control-row .value {
    font-size: 14px;
    color: #ccc;
    width: 50px;
    text-align: right;
    flex-shrink: 0;
  }

  #startBtn {
    background: #0a84ff;
    color: #fff;
    border: none;
    border-radius: 12px;
    padding: 14px;
    font-size: 17px;
    font-weight: 600;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }

  #startBtn:active { opacity: 0.7; }

  /* 提词界面 */
  #prompter {
    display: none;
    position: fixed;
    inset: 0;
    background: #000;
    flex-direction: column;
  }

  #prompter.active {
    display: flex;
  }

  .prompter-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 16px;
    background: rgba(0,0,0,0.8);
    flex-shrink: 0;
    z-index: 10;
  }

  .prompter-header button {
    background: #333;
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 8px 14px;
    font-size: 14px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  }

  .prompter-header button:active { opacity: 0.7; }
  .prompter-header button.primary { background: #0a84ff; }

  .speed-display {
    font-size: 13px;
    color: #aaa;
  }

  #prompterCanvas {
    flex: 1;
    width: 100%;
  }

  /* 隐藏的视频用于 PiP */
  #pipVideo {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 320px;
    height: 180px;
    opacity: 0.01;
    pointer-events: none;
    z-index: -1;
  }

  .status-bar {
    padding: 6px 16px;
    text-align: center;
    font-size: 12px;
    color: #666;
    flex-shrink: 0;
  }
</style>
</head>
<body>

<div id="editor">
  <h1>口播提词器</h1>

  <textarea id="textInput" placeholder="在这里粘贴或输入你的口播稿...&#10;&#10;支持多段文字，提词器会自动匀速滚动。"></textarea>

  <div class="controls">
    <div class="control-row">
      <label>速度</label>
      <input type="range" id="speedRange" min="1" max="10" step="0.5" value="3">
      <span class="value" id="speedValue">3</span>
    </div>
    <div class="control-row">
      <label>字号</label>
      <input type="range" id="fontRange" min="20" max="60" step="2" value="36">
      <span class="value" id="fontValue">36</span>
    </div>
    <div class="control-row">
      <label>每屏行数</label>
      <input type="range" id="linesRange" min="1" max="4" step="1" value="2">
      <span class="value" id="linesValue">2</span>
    </div>
  </div>

  <button id="startBtn">开始提词</button>
</div>

<div id="prompter">
  <div class="prompter-header">
    <button id="backBtn">← 返回</button>
    <span class="speed-display" id="speedDisplay">速度: 3</span>
    <button id="pipBtn" class="primary">画中画</button>
  </div>
  <canvas id="prompterCanvas"></canvas>
  <div class="status-bar" id="statusBar">点击画面 暂停/继续 | 画中画后切到相机录制</div>
</div>

<!-- 用于 PiP 的视频：1x1 黑色像素 MP4，循环播放 -->
<video id="pipVideo" muted playsinline loop></video>

<script>
(function() {
  const editor = document.getElementById('editor');
  const prompter = document.getElementById('prompter');
  const textInput = document.getElementById('textInput');
  const speedRange = document.getElementById('speedRange');
  const fontRange = document.getElementById('fontRange');
  const linesRange = document.getElementById('linesRange');
  const speedValue = document.getElementById('speedValue');
  const fontValue = document.getElementById('fontValue');
  const linesValue = document.getElementById('linesValue');
  const startBtn = document.getElementById('startBtn');
  const backBtn = document.getElementById('backBtn');
  const pipBtn = document.getElementById('pipBtn');
  const canvas = document.getElementById('prompterCanvas');
  const pipVideo = document.getElementById('pipVideo');
  const speedDisplay = document.getElementById('speedDisplay');
  const statusBar = document.getElementById('statusBar');
  const ctx = canvas.getContext('2d');

  let speed = 3;
  let fontSize = 36;
  let scrollY = 0;
  let totalHeight = 0;
  let isPaused = false;
  let lines = [];
  let isPiP = false;
  let intervalId = null;
  let pipLinesPerCue = 2;
  let textTrack = null;

  // 生成最小的黑色 MP4 视频（base64）
  // 这是一个 1s 的黑色静音 MP4
  const BLANK_VIDEO_BASE64 = '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';

  // 控制面板事件
  speedRange.addEventListener('input', () => {
    speed = parseFloat(speedRange.value);
    speedValue.textContent = speed;
    speedDisplay.textContent = '速度: ' + speed;
  });

  fontRange.addEventListener('input', () => {
    fontSize = parseInt(fontRange.value);
    fontValue.textContent = fontSize;
  });

  linesRange.addEventListener('input', () => {
    pipLinesPerCue = parseInt(linesRange.value);
    linesValue.textContent = pipLinesPerCue;
  });

  // 开始提词
  startBtn.addEventListener('click', () => {
    const text = textInput.value.trim();
    if (!text) {
      textInput.focus();
      startBtn.textContent = '请先输入文字！';
      startBtn.style.background = '#ff453a';
      setTimeout(() => {
        startBtn.textContent = '开始提词';
        startBtn.style.background = '#0a84ff';
      }, 2000);
      return;
    }
    enterPrompter(text);
  });

  backBtn.addEventListener('click', exitPrompter);

  // 进入提词界面
  function enterPrompter(text) {
    editor.style.display = 'none';
    prompter.classList.add('active');

    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        resizeCanvas();

        const rect = canvas.getBoundingClientRect();
        if (rect.width === 0 || rect.height === 0) {
          const dpr = window.devicePixelRatio || 1;
          canvas.width = window.innerWidth * dpr;
          canvas.height = (window.innerHeight - 80) * dpr;
          ctx.scale(dpr, dpr);
        }

        wrapText(text);
        scrollY = 0;
        isPaused = false;

        requestWakeLock();
        startRendering();

        // 准备 PiP 视频和字幕
        preparePipVideo();
      });
    });
  }

  function exitPrompter() {
    stopRendering();
    exitPiP();
    prompter.classList.remove('active');
    editor.style.display = 'flex';
    releaseWakeLock();
  }

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
  }

  function wrapText(text) {
    const maxWidth = (canvas.width / (window.devicePixelRatio || 1)) - 40;
    ctx.font = fontSize + 'px -apple-system, BlinkMacSystemFont, sans-serif';

    const paragraphs = text.split('\n');
    lines = [];

    for (const para of paragraphs) {
      if (para.trim() === '') {
        lines.push('');
        continue;
      }
      let currentLine = '';
      for (const char of para) {
        const testLine = currentLine + char;
        if (ctx.measureText(testLine).width > maxWidth && currentLine.length > 0) {
          lines.push(currentLine);
          currentLine = char;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) lines.push(currentLine);
    }

    const lineHeight = fontSize * 1.8;
    totalHeight = lines.length * lineHeight + canvas.height / (window.devicePixelRatio || 1);
  }

  function getCurrentLineIndex() {
    const lineHeight = fontSize * 1.8;
    return Math.floor(scrollY / lineHeight);
  }

  // 主屏渲染
  function drawFrame() {
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const lineHeight = fontSize * 1.8;

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, w, h);

    const guideLine = h * 0.3;
    ctx.strokeStyle = 'rgba(10, 132, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, guideLine);
    ctx.lineTo(w, guideLine);
    ctx.stroke();

    ctx.font = fontSize + 'px -apple-system, BlinkMacSystemFont, sans-serif';
    ctx.textBaseline = 'top';

    const startY = guideLine - scrollY;

    for (let i = 0; i < lines.length; i++) {
      const y = startY + i * lineHeight;
      if (y + lineHeight < 0) continue;
      if (y > h) break;

      const distFromGuide = Math.abs(y - guideLine);
      const opacity = Math.max(0.3, 1 - distFromGuide / (h * 0.5));
      ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
      ctx.fillText(lines[i], 20, y);
    }

    if (!isPaused) {
      scrollY += speed * 0.5;
      if (scrollY > totalHeight - h) {
        isPaused = true;
        statusBar.textContent = '已滚动到末尾';
      }
    }

    // 同步 PiP 视频的 currentTime 到当前进度
    syncPipTime();
  }

  // === PiP 方案：真实视频 + TextTrack 字幕 ===

  function preparePipVideo() {
    // 加载一个最小的黑色视频
    const blob = base64ToBlob(BLANK_VIDEO_BASE64, 'video/mp4');
    const url = URL.createObjectURL(blob);
    pipVideo.src = url;
    pipVideo.load();

    // 添加字幕轨道
    buildTextTrack();
  }

  function base64ToBlob(base64, type) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return new Blob([bytes], { type });
  }

  function buildTextTrack() {
    // 移除旧的 track
    while (pipVideo.textTracks.length > 0 && pipVideo.firstChild) {
      pipVideo.removeChild(pipVideo.firstChild);
    }

    // 创建新 track
    textTrack = pipVideo.addTextTrack('captions', '提词', 'zh');
    textTrack.mode = 'showing';

    // 计算每个 cue 的时长
    // speed * 0.5 px/frame, 30fps => speed * 15 px/sec
    // lineHeight = fontSize * 1.8
    // 每行时间 = lineHeight / (speed * 15) 秒
    const lineHeight = fontSize * 1.8;
    const secPerLine = lineHeight / (speed * 15);

    // 每 pipLinesPerCue 行一个 cue
    for (let i = 0; i < lines.length; i += pipLinesPerCue) {
      const startTime = i * secPerLine;
      const endTime = (i + pipLinesPerCue) * secPerLine;

      let cueText = '';
      for (let j = 0; j < pipLinesPerCue && (i + j) < lines.length; j++) {
        if (j > 0) cueText += '\n';
        cueText += lines[i + j] || ' ';
      }

      try {
        const cue = new VTTCue(startTime, endTime, cueText);
        cue.line = -1; // 底部显示
        cue.size = 100;
        textTrack.addCue(cue);
      } catch (e) {
        // VTTCue 不可用时忽略
      }
    }
  }

  function syncPipTime() {
    if (!isPiP || !pipVideo || pipVideo.paused) return;

    const lineHeight = fontSize * 1.8;
    const secPerLine = lineHeight / (speed * 15);
    const currentLine = getCurrentLineIndex();
    const targetTime = currentLine * secPerLine;

    // 只在差距较大时同步，避免频繁 seek
    if (Math.abs(pipVideo.currentTime - targetTime) > secPerLine * 0.5) {
      pipVideo.currentTime = targetTime;
    }
  }

  function startRendering() {
    stopRendering();
    const fps = 30;
    intervalId = setInterval(() => {
      drawFrame();
    }, 1000 / fps);
  }

  function stopRendering() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
  }

  // 点击暂停/继续
  canvas.addEventListener('click', () => {
    isPaused = !isPaused;
    statusBar.textContent = isPaused ? '已暂停 - 点击继续' : '滚动中 - 点击暂停';
  });

  // PiP
  pipBtn.addEventListener('click', () => {
    if (isPiP) {
      exitPiP();
      return;
    }

    // 确保视频已加载
    if (!pipVideo.src) {
      preparePipVideo();
    }

    // 同步播放视频（需要在用户手势中）
    pipVideo.play().then(() => {
      // play 成功后立即请求 PiP
      if (pipVideo.requestPictureInPicture) {
        pipVideo.requestPictureInPicture().then(() => {
          isPiP = true;
          pipBtn.textContent = '退出画中画';
          statusBar.textContent = '画中画已启动 - 切到相机App录制';
          setupMediaSession();
        }).catch((e) => {
          statusBar.textContent = 'PiP失败: ' + e.message;
        });
      } else if (pipVideo.webkitSetPresentationMode) {
        // Safari fallback
        pipVideo.webkitSetPresentationMode('picture-in-picture');
        isPiP = true;
        pipBtn.textContent = '退出画中画';
        statusBar.textContent = '画中画已启动 - 切到相机App录制';
        setupMediaSession();
      } else {
        statusBar.textContent = '浏览器不支持画中画';
      }
    }).catch((e) => {
      statusBar.textContent = '视频播放失败: ' + e.message;
    });
  });

  pipVideo.addEventListener('leavepictureinpicture', () => {
    isPiP = false;
    pipBtn.textContent = '画中画';
  });

  // Safari webkit event
  pipVideo.addEventListener('webkitpresentationmodechanged', () => {
    if (pipVideo.webkitPresentationMode !== 'picture-in-picture') {
      isPiP = false;
      pipBtn.textContent = '画中画';
    }
  });

  function exitPiP() {
    try {
      if (document.pictureInPictureElement) {
        document.exitPictureInPicture().catch(() => {});
      } else if (pipVideo.webkitSetPresentationMode) {
        pipVideo.webkitSetPresentationMode('inline');
      }
    } catch (e) {}
    isPiP = false;
    pipBtn.textContent = '画中画';
  }

  // Media Session
  function setupMediaSession() {
    if (!('mediaSession' in navigator)) return;

    navigator.mediaSession.metadata = new MediaMetadata({
      title: '口播提词器',
      artist: '滚动提词中...',
    });

    navigator.mediaSession.setActionHandler('seekforward', () => {
      speed = Math.min(10, speed + 0.5);
      speedRange.value = speed;
      speedValue.textContent = speed;
      speedDisplay.textContent = '速度: ' + speed;
    });

    navigator.mediaSession.setActionHandler('seekbackward', () => {
      speed = Math.max(1, speed - 0.5);
      speedRange.value = speed;
      speedValue.textContent = speed;
      speedDisplay.textContent = '速度: ' + speed;
    });

    navigator.mediaSession.setActionHandler('play', () => {
      isPaused = false;
      statusBar.textContent = '滚动中';
    });

    navigator.mediaSession.setActionHandler('pause', () => {
      isPaused = true;
      statusBar.textContent = '已暂停';
    });
  }

  // 屏幕常亮
  let wakeLock = null;

  async function requestWakeLock() {
    if ('wakeLock' in navigator) {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
      } catch (e) {}
    }
  }

  function releaseWakeLock() {
    if (wakeLock) {
      wakeLock.release().catch(() => {});
      wakeLock = null;
    }
  }

  window.addEventListener('resize', () => {
    if (prompter.classList.contains('active')) {
      resizeCanvas();
      const text = textInput.value.trim();
      if (text) wrapText(text);
    }
  });

  document.addEventListener('touchmove', (e) => {
    if (prompter.classList.contains('active')) {
      e.preventDefault();
    }
  }, { passive: false });

  textInput.value = '';

})();
</script>

</body>
</html>
